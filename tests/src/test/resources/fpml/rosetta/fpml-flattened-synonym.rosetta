namespace cdm.fpml.flattened
version "${project.version}"

import cdm.fpml.flattened.* as fpml
import cdm.fpml.rewrite.common.*
import cdm.fpml.rewrite.party.*
import cdm.fpml.rewrite.identifier.*

/*
 //Need to look at how we are going to call this from the level above. All the payer/receiver account and party references come from different products. Will this still require a custom mapper?
    cdm.base.staticdata.party.Party from party Party, account Account, relatedPerson RelatedPerson, payerAccountReference AccountReference, payerPartyReference PartyReference, receiverAccountReference AccountReference, receiverPartyReference PartyReference:
        [meta key from party -> id]
        + name
            [from party -> partyName -> value]
            [meta scheme from party -> partyName -> partyNameScheme] // NOTE: synonym is wrong???
        + partyId
            [from party -> partyId]
        + person
            [from party -> person]
        + account
            [from account, payerAccountReference, payerPartyReference, receiverAccountReference, receiverPartyReference]
        + contactInformation
            [from party -> contactInfo, party -> country]
        + businessUnit
            [from party -> businessUnit]
        + personRole
            [from relatedPerson]

    cdm.base.staticdata.party.PartyIdentifier from PartyId:
        + identifier
            [from value]
            [meta scheme from partyIdScheme]
        + identifierType
            [from partyIdScheme]

    //Bug in DSL requires fpml types to be imported https://github.com/finos/rune-dsl/issues/794
    PartyIdentifierTypeEnum from string:
        [from if item = "http://www.fpml.org/coding-scheme/external/iso17442"
            then PartyIdentifierTypeEnum -> LEI
            else if item = "http://www.fpml.org/coding-scheme/external/iso9362"
                then PartyIdentifierTypeEnum -> BIC
            else if item = "http://www.fpml.org/coding-scheme/external/iso10383"
                then  PartyIdentifierTypeEnum -> MIC]

    cdm.base.staticdata.party.Account from Account, payerAccountReference AccountReference, payerPartyReference PartyReference, receiverAccountReference AccountReference, receiverPartyReference PartyReference:
        [meta key from id]
        + partyReference
            [meta reference from id, payerAccountReference, payerPartyReference, receiverAccountReference, receiverPartyReference]
        + accountNumber
            [from accountId only-element -> value]
            [meta scheme from accountId only-element -> accountIdScheme ]
        + accountName
            [from accountName -> value]
            [meta scheme from accountName -> accountNameScheme]
        + accountType
            [from accountType -> value to-enum cdm.base.staticdata.party.AccountTypeEnum]
            [meta scheme from accountType -> accountTypeScheme]
        + accountBeneficiary
            [meta reference from accountBeneficiary -> href]
        + servicingParty
            [meta reference from servicingParty -> href]

    string from accountId string, payerAccountReference AccountReference, payerPartyReference PartyReference, receiverAccountReference AccountReference, receiverPartyReference PartyReference:
        [from if payerAccountReference -> href = accountId
            then payerPartyReference -> href
            else if receiverAccountReference -> href = accountId
            then receiverPartyReference -> href
            else accountId] //This recreated the mapper behaviour however I believe this is a mistake to stamp an accountId on a partyRererence

    cdm.base.staticdata.party.NaturalPerson from Person:
        [meta key from id]
        + honorific
            [from honorific]
        + firstName
            [from firstName]
        + middleName
            [from middleName]
        + initial
            [from initial]
        + surname
            [from surname]
        + suffix
            [from suffix]
        + dateOfBirth
            [from dateOfBirth]
        + contactInformation
            [from contactInfo, country]

    cdm.base.staticdata.party.ContactInformation from ContactInformation, country CountryCode:
        + telephone
            [from telephone]
        + address
            [from address, country]
        + email
            [from email]

    cdm.base.staticdata.party.TelephoneNumber from TelephoneNumber:
        + number
            [from number]
        + telephoneNumberType
            [from telephoneNumberType]

    //Bug in DSL requires fpml types to be imported https://github.com/finos/rune-dsl/issues/794
    TelephoneTypeEnum from FpmlTelephoneTypeEnum:
        [from
            if item = FpmlTelephoneTypeEnum -> WORK then TelephoneTypeEnum -> Work
            else if item = FpmlTelephoneTypeEnum -> MOBILE then TelephoneTypeEnum -> Mobile
            else if item = FpmlTelephoneTypeEnum -> FAX then TelephoneTypeEnum -> Fax
            else if item = FpmlTelephoneTypeEnum -> PERSONAL then TelephoneTypeEnum -> Personal
        ]

    cdm.base.staticdata.party.Address from address Address, countryOverride CountryCode:
        + street
            [from address -> streetAddress -> streetLine]
        + city
            [from address -> city]
        + state
            [from address -> state]
        + country
            [from countryOverride -> value default address -> country -> value]
            [meta scheme from countryOverride -> countryScheme default address -> country -> countryScheme]
        + postalCode
            [from address -> postalCode]

    cdm.base.staticdata.party.BusinessUnit from BusinessUnit:
        [meta key from id]
        + name
            [from name]
        + contactInformation
            [from contactInfo, country]
        + identifier
            [from item]

    cdm.base.staticdata.identifier.Identifier from BusinessUnit:
        // [meta key from id]
        // [meta key from "id" path "versionedTradeId->tradeId"]
        // + issuerReference
        //    [value "issuer" meta "href"]
        //    [value "partyReference" meta "href"]
        //+ issuer
        //    [value "issuer" maps 2 meta "issuerIdScheme"]
        + assignedIdentifier
            [from businessUnitId]

    cdm.base.staticdata.identifier.AssignedIdentifier from Unit:
        + identifier
            [from value]
            [meta scheme from unitScheme]
        //    [value "tradeId" maps 2 meta "tradeIdScheme"]
        //    [value "tradeId" path "versionedTradeId" meta "tradeIdScheme"]
        //    [value "businessUnitId" meta "unitScheme"]
        //    [value "eventId" meta "eventIdScheme"]
        //    [value "messageId"]
        //    [value "collateralPortfolio"]
        //    [value "linkId" path "partyTradeIdentifier" mapper "LinkId"]
        // + version
        //    [value "version" path "versionedTradeId"]
        //    [value "version"]

    cdm.base.staticdata.party.NaturalPersonRole from RelatedPerson:
        + personReference
            [meta reference from personReference -> href]
        + role
            [from role -> value to-enum cdm.base.staticdata.party.NaturalPersonRoleEnum]
            [meta scheme from role -> personRoleScheme]
*/

translate source FpML {

    translate party fpml.Party, account fpml.Account, relatedPerson fpml.RelatedPerson,
              payerAccountReference fpml.AccountReference, payerPartyReference fpml.PartyReference,
              receiverAccountReference fpml.AccountReference, receiverPartyReference fpml.PartyReference
        to Party {
            id:                 party -> id,
            name:               StringWithScheme [party -> partyName] {
                                    scheme: party -> partyName -> partyNameScheme
                                },
            partyId:            translate party -> partyId to PartyIdentifier,
            person:             translate party -> person to NaturalPerson,
            account:            translate account, payerAccountReference, payerPartyReference, receiverAccountReference, receiverPartyReference to Account,
            contactInformation: translate party -> contactInfo, party -> country to ContactInformation,
            businessUnit:       translate party -> businessUnit to BusinessUnit,
            personRole:         translate relatedPerson to NaturalPersonRole
    }

    translate partyId fpml.PartyId to PartyIdentifier {
        identifier:     StringWithScheme [partyId] {
                            scheme: partyId -> partyIdScheme
                        },
        identifierType: partyId -> partyIdScheme switch
                            "http://www.fpml.org/coding-scheme/external/iso17442"   then LEI,
                            "http://www.fpml.org/coding-scheme/external/iso9362"    then BIC,
                            "http://www.fpml.org/coding-scheme/external/iso10383"   then MIC,
                            default empty
    }

    translate fpml.Person to NaturalPerson {
        id:                 id,
        honorific:          honorific,
        firstName:          firstName,
        middleName:         middleName,
        initial:            initial,
        surname:            surname,
        suffix:             suffix,
        dateOfBirth:        dateOfBirth,
        contactInformation: translate contactInfo, country to ContactInformation,
        personId:           empty
    }

    translate account fpml.Account, payerAccountReference fpml.AccountReference, payerPartyReference fpml.PartyReference, receiverAccountReference fpml.AccountReference, receiverPartyReference fpml.PartyReference
        to Account {
            id:                 account -> id,
            partyReference:
                                MapPartyReference(account -> id, payerAccountReference, payerPartyReference, receiverAccountReference, receiverPartyReference)
                                    as-reference,
            accountNumber:
                                account -> accountId only-element
                                    then extract accountId [
                                        StringWithScheme [accountId] { scheme: accountId -> accountIdScheme }
                                    ],
            accountName:        StringWithScheme [account -> accountName] {
                                    scheme: account -> accountName -> accountNameScheme
                                },
            accountType:        AccountTypeEnumWithScheme [account -> accountType to-enum AccountTypeEnum] {
                                    scheme: account -> accountType -> accountTypeScheme
                                },
            accountBeneficiary: account -> accountBeneficiary -> href as-reference,
            servicingParty:     account -> servicingParty -> href as-reference
    }

    func MapPartyReference:
        inputs:
            accountId string (1..1)
            payerAccountReference fpml.AccountReference (1..1)
            payerPartyReference fpml.PartyReference (1..1)
            receiverAccountReference fpml.AccountReference (1..1)
            receiverPartyReference fpml.PartyReference (1..1)
        output:
            partyReference string (1..1)

        set partyReference:
            if payerAccountReference -> href = accountId
            then payerPartyReference -> href
            else if receiverAccountReference -> href = accountId
            then receiverPartyReference -> href
            else accountId


    translate contactInformation fpml.ContactInformation, countryOverride fpml.CountryCode to ContactInformation {
        telephone:  contactInformation -> telephone extract translate item to TelephoneNumber,
        address:    translate contactInformation -> address, countryOverride to Address,
        email:      contactInformation -> email,
        ...
    }

    translate fpml.TelephoneNumber to TelephoneNumber {
        number:                 number,
        telephoneNumberType:    telephoneNumberType switch
                                    WORK        then TelephoneTypeEnum -> Work,
                                    MOBILE      then TelephoneTypeEnum -> Mobile,
                                    FAX         then TelephoneTypeEnum -> Fax,
                                    PERSONAL    then TelephoneTypeEnum -> Personal
    }

    translate address fpml.Address, countryOverride fpml.CountryCode to Address {
        street:     address -> streetAddress -> streetLine,
        city:       address -> city,
        state:      address -> state,
        country:    StringWithScheme [countryOverride default address -> country] {
                        scheme: (countryOverride default address -> country) -> countryScheme
                    },
        postalCode: address -> postalCode
    }

    translate fpml.BusinessUnit to BusinessUnit {
        id:                 id,
        name:               name,
        contactInformation: translate contactInfo, country to ContactInformation,
        identifier:         translate item to Identifier
    }

    translate fpml.BusinessUnit to Identifier {
        id:                 empty,
        issuerReference:    empty,
        issuer:             empty,
        assignedIdentifier: translate businessUnitId to AssignedIdentifier

    }

    translate unit fpml.Unit to AssignedIdentifier {
        identifier: StringWithScheme [unit] {
                        scheme: unit -> unitScheme
                    },
        version:    empty
    }

    translate fpml.RelatedPerson to NaturalPersonRole {
        personReference:    personReference -> href as-reference,
        role:               NaturalPersonRoleEnumWithScheme [role to-enum NaturalPersonRoleEnum] {
                                scheme: role -> personRoleScheme
                            }
    }

}
