namespace fpml.flattened
version "${project.version}"

import cdm.fpml.flattened.* as fpml
import cdm.base.staticdata.party.*
import cdm.base.staticdata.identifier.*

import cdm.base.staticdata.party.TelephoneTypeEnum

/*
 //Need to look at how we are going to call this from the level above. All the payer/receiver account and party references come from different products. Will this still require a custom mapper?
    cdm.base.staticdata.party.Party from party Party, account Account, relatedPerson RelatedPerson, payerAccountReference AccountReference, payerPartyReference PartyReference, receiverAccountReference AccountReference, receiverPartyReference PartyReference:
        [meta key from party -> id]
        + name
            [from party -> partyName -> value]
            [meta scheme from party -> partyName -> partyNameScheme] // NOTE: synonym is wrong???
        + partyId
            [from party -> partyId]
        + person
            [from party -> person]
        + account
            [from account, payerAccountReference, payerPartyReference, receiverAccountReference, receiverPartyReference]
        + contactInformation
            [from party -> contactInfo, party -> country]
        + businessUnit
            [from party -> businessUnit]
        + personRole
            [from relatedPerson]

    cdm.base.staticdata.party.PartyIdentifier from PartyId:
        + identifier
            [from value]
            [meta scheme from partyIdScheme]
        + identifierType
            [from partyIdScheme]

    //Bug in DSL requires fpml types to be imported https://github.com/finos/rune-dsl/issues/794
    PartyIdentifierTypeEnum from string:
        [from if item = "http://www.fpml.org/coding-scheme/external/iso17442"
            then PartyIdentifierTypeEnum -> LEI
            else if item = "http://www.fpml.org/coding-scheme/external/iso9362"
                then PartyIdentifierTypeEnum -> BIC
            else if item = "http://www.fpml.org/coding-scheme/external/iso10383"
                then  PartyIdentifierTypeEnum -> MIC]

    cdm.base.staticdata.party.Account from Account, payerAccountReference AccountReference, payerPartyReference PartyReference, receiverAccountReference AccountReference, receiverPartyReference PartyReference:
        [meta key from id]
        + partyReference
            [meta reference from id, payerAccountReference, payerPartyReference, receiverAccountReference, receiverPartyReference]
        + accountNumber
            [from accountId only-element -> value]
            [meta scheme from accountId only-element -> accountIdScheme ]
        + accountName
            [from accountName -> value]
            [meta scheme from accountName -> accountNameScheme]
        + accountType
            [from accountType -> value to-enum cdm.base.staticdata.party.AccountTypeEnum]
            [meta scheme from accountType -> accountTypeScheme]
        + accountBeneficiary
            [meta reference from accountBeneficiary -> href]
        + servicingParty
            [meta reference from servicingParty -> href]

    string from accountId string, payerAccountReference AccountReference, payerPartyReference PartyReference, receiverAccountReference AccountReference, receiverPartyReference PartyReference:
        [from if payerAccountReference -> href = accountId
            then payerPartyReference -> href
            else if receiverAccountReference -> href = accountId
            then receiverPartyReference -> href
            else accountId] //This recreated the mapper behaviour however I believe this is a mistake to stamp an accountId on a partyRererence

    cdm.base.staticdata.party.NaturalPerson from Person:
        [meta key from id]
        + honorific
            [from honorific]
        + firstName
            [from firstName]
        + middleName
            [from middleName]
        + initial
            [from initial]
        + surname
            [from surname]
        + suffix
            [from suffix]
        + dateOfBirth
            [from dateOfBirth]
        + contactInformation
            [from contactInfo, country]

    cdm.base.staticdata.party.ContactInformation from ContactInformation, country CountryCode:
        + telephone
            [from telephone]
        + address
            [from address, country]
        + email
            [from email]

    cdm.base.staticdata.party.TelephoneNumber from TelephoneNumber:
        + number
            [from number]
        + telephoneNumberType
            [from telephoneNumberType]

    //Bug in DSL requires fpml types to be imported https://github.com/finos/rune-dsl/issues/794
    TelephoneTypeEnum from FpmlTelephoneTypeEnum:
        [from
            if item = FpmlTelephoneTypeEnum -> WORK then TelephoneTypeEnum -> Work
            else if item = FpmlTelephoneTypeEnum -> MOBILE then TelephoneTypeEnum -> Mobile
            else if item = FpmlTelephoneTypeEnum -> FAX then TelephoneTypeEnum -> Fax
            else if item = FpmlTelephoneTypeEnum -> PERSONAL then TelephoneTypeEnum -> Personal
        ]

    cdm.base.staticdata.party.Address from address Address, countryOverride CountryCode:
        + street
            [from address -> streetAddress -> streetLine]
        + city
            [from address -> city]
        + state
            [from address -> state]
        + country
            [from countryOverride -> value default address -> country -> value]
            [meta scheme from countryOverride -> countryScheme default address -> country -> countryScheme]
        + postalCode
            [from address -> postalCode]

    cdm.base.staticdata.party.BusinessUnit from BusinessUnit:
        [meta key from id]
        + name
            [from name]
        + contactInformation
            [from contactInfo, country]
        + identifier
            [from item]

    cdm.base.staticdata.identifier.Identifier from BusinessUnit:
        // [meta key from id]
        // [meta key from "id" path "versionedTradeId->tradeId"]
        // + issuerReference
        //    [value "issuer" meta "href"]
        //    [value "partyReference" meta "href"]
        //+ issuer
        //    [value "issuer" maps 2 meta "issuerIdScheme"]
        + assignedIdentifier
            [from businessUnitId]

    cdm.base.staticdata.identifier.AssignedIdentifier from Unit:
        + identifier
            [from value]
            [meta scheme from unitScheme]
        //    [value "tradeId" maps 2 meta "tradeIdScheme"]
        //    [value "tradeId" path "versionedTradeId" meta "tradeIdScheme"]
        //    [value "businessUnitId" meta "unitScheme"]
        //    [value "eventId" meta "eventIdScheme"]
        //    [value "messageId"]
        //    [value "collateralPortfolio"]
        //    [value "linkId" path "partyTradeIdentifier" mapper "LinkId"]
        // + version
        //    [value "version" path "versionedTradeId"]
        //    [value "version"]

    cdm.base.staticdata.party.NaturalPersonRole from RelatedPerson:
        + personReference
            [meta reference from personReference -> href]
        + role
            [from role -> value to-enum cdm.base.staticdata.party.NaturalPersonRoleEnum]
            [meta scheme from role -> personRoleScheme]
*/

translate source FpML {

    translate party fpml.Party, account fpml.Account, relatedPerson fpml.RelatedPerson, payerAccountReference fpml.AccountReference, payerPartyReference fpml.PartyReference, receiverAccountReference fpml.AccountReference, receiverPartyReference fpml.PartyReference to cdm.base.staticdata.party.Party {
        //[meta key from party -> id]
        name: party -> partyName -> value,
        partyId: party -> partyId extract translate item to PartyIdentifier,
        person: party -> person extract translate item to NaturalPerson,
        account: translate account, payerAccountReference, payerPartyReference, receiverAccountReference, receiverPartyReference to Account,
        contactInformation: translate party -> contactInfo, party -> country to ContactInformation,
        businessUnit: party -> businessUnit extract translate item to BusinessUnit,
        personRole: translate relatedPerson to NaturalPersonRole
    }

    translate partyId fpml.PartyId to PartyIdentifier {
        identifier: partyId -> value,
        // [meta scheme from partyIdScheme]
        identifierType: partyId -> partyIdScheme to-string switch
                "http://www.fpml.org/coding-scheme/external/iso17442" then LEI,
                "http://www.fpml.org/coding-scheme/external/iso9362" then BIC,
                "http://www.fpml.org/coding-scheme/external/iso10383" then MIC
    }

    translate person fpml.Person to NaturalPerson {
        honorific: person -> honorific,
        firstName: person -> firstName,
        middleName: person -> middleName,
        initial: person -> initial,
        surname: person -> surname,
        suffix: person -> suffix,
        dateOfBirth: person -> dateOfBirth,
        contactInformation: empty,
        personId: empty
    }

    translate account fpml.Account, payerAccountReference fpml.AccountReference, payerPartyReference fpml.PartyReference, receiverAccountReference fpml.AccountReference, receiverPartyReference fpml.PartyReference
        to Account {
            //[meta key from id]
            partyReference: empty, //needs meta then call MapPartyReference
            accountNumber: account -> accountId only-element -> value,
            //[meta scheme from accountId only-element -> accountIdScheme ]
            accountName: account -> accountName -> value,
            //[meta scheme from accountName -> accountNameScheme]
            accountType: account -> accountType -> value to-enum cdm.base.staticdata.party.AccountTypeEnum,
            //[meta scheme from accountType -> accountTypeScheme]
            accountBeneficiary: empty, //needs meta: [meta reference from accountBeneficiary -> href]
            servicingParty: empty //needs meta: [meta reference from servicingParty -> href]
    }

    func MapPartyReference:
        inputs:
            accountId string (1..1)
            payerAccountReference fpml.AccountReference (1..1)
            payerPartyReference fpml.PartyReference (1..1)
            receiverAccountReference fpml.AccountReference (1..1)
            receiverPartyReference fpml.PartyReference (1..1)
        output:
            partyReference string (1..1)

        set partyReference: if payerAccountReference -> href = accountId
            then payerPartyReference -> href
            else if receiverAccountReference -> href = accountId
            then receiverPartyReference -> href
            else accountId


    translate contactInformation fpml.ContactInformation, country fpml.CountryCode to ContactInformation {
        telephone: contactInformation -> telephone extract translate item to TelephoneNumber,
        address: translate contactInformation -> address, country to Address,
        email: contactInformation -> email,
        ...
    }

    translate telephoneNumber fpml.TelephoneNumber to TelephoneNumber {
        number: telephoneNumber -> number,
        telephoneNumberType: telephoneNumber -> telephoneNumberType switch
            WORK then TelephoneTypeEnum -> Work,
            MOBILE then TelephoneTypeEnum -> Mobile,
            FAX then TelephoneTypeEnum -> Fax,
            PERSONAL then TelephoneTypeEnum -> Personal
    }

    translate address fpml.Address, countryOverride fpml.CountryCode to Address {
        street: address -> streetAddress -> streetLine,
        city: address -> city,
        state: address -> state,
        country: countryOverride -> value default address -> country -> value,
        //[meta scheme from countryOverride -> countryScheme default address -> country -> countryScheme]
        postalCode: address -> postalCode
    }

    translate businessUnit fpml.BusinessUnit to BusinessUnit {
        name: businessUnit -> name,
        contactInformation: translate businessUnit -> contactInfo, businessUnit -> country to ContactInformation,
        identifier: translate businessUnit to Identifier
    }

    translate businessUnit fpml.BusinessUnit to Identifier {
        issuerReference: empty, //needs meta
        issuer: empty, //needs meta
        assignedIdentifier: translate businessUnit -> businessUnitId to AssignedIdentifier

    }

    translate unit fpml.Unit to AssignedIdentifier {
        identifier: unit -> value,
        //[meta scheme from unitScheme]
        version: empty
    }

    translate relatedPerson fpml.RelatedPerson to NaturalPersonRole {
        personReference: empty, //needs meta: [meta reference from personReference -> href]
        role: relatedPerson -> role -> value to-enum NaturalPersonRoleEnum
        //role [meta scheme from role -> personRoleScheme]
    }

}